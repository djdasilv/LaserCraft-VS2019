//===========================================================================
/*
    Software License Agreement (BSD License)
    Copyright (c) 2003-2023, CHAI3D
    (www.chai3d.org)

    All rights reserved.
*/
//===========================================================================
 
/*! 


\page chapter9-mesh Mesh Objects



\section section9-1 Introduction

\image html images/fig-mesh-model.png "Mesh objects are shapes composed of triangles and vertices."

In CHAI3D, a polygon mesh is a collection of vertices and triangles that define the 
shape of a polyhedral object. 

A <b>vertex</b> is a position along with other information such as <b>color</b>, 
<b>normal</b> vector and <b>texture coordinates</b>. Two vertices connected by a 
straight line become an <b>edge</b>. Three vertices, connected to each other by three 
edges, define a <b>triangle</b>, which is the simplest polygon in Euclidean space.

Mesh objects may be translated, rotated, or resized, and have one material 
and texture property assigned to them.

The following code illustrates how to create a textured square composed of 4 vertices 
and 2 triangles.

@code

    using namespace chai3d;
	
    // create a mesh
    object = new cMesh();
	
    // create a texture map
    object->m_texture = cTexture2d::create();

	// load a texture file
	object->m_texture->loadFromFile("myTexture.jpg");

    // enable texture mapping
    object1->setUseTexture(true);
	
	// set material to white
    object1->m_material->setWhite();

    // create vertices
    int vertex0 = object0->newVertex();
    int vertex1 = object0->newVertex();
    int vertex2 = object0->newVertex();
    int vertex3 = object0->newVertex();

    // set position, surface normal, and texture coordinate for vertex 0
    object0->m_vertices->setLocalPos(vertex0,-0.1,-0.1, 0.0);
    object0->m_vertices->setNormal(vertex0, 0.0, 0.0, 1.0);
    object0->m_vertices->setTexCoord(vertex0, 0.0, 0.0);

    // set position, surface normal, and texture coordinate for vertex 1
    object0->m_vertices->setLocalPos(vertex1, 0.1,-0.1, 0.0);
    object0->m_vertices->setNormal(vertex1, 0.0, 0.0, 1.0);
    object0->m_vertices->setTexCoord(vertex1, 1.0, 0.0);

    // set position, surface normal, and texture coordinate for vertex 2
    object0->m_vertices->setLocalPos(vertex2, 0.1, 0.1, 0.0);
    object0->m_vertices->setNormal(vertex2, 0.0, 0.0, 1.0);
    object0->m_vertices->setTexCoord(vertex2, 1.0, 1.0);

    // set position, surface normal, and texture coordinate for vertex 3
    object0->m_vertices->setLocalPos(vertex3,-0.1, 0.1, 0.0);
    object0->m_vertices->setNormal(vertex3, 0.0, 0.0, 1.0);
    object0->m_vertices->setTexCoord(vertex3, 0.0, 1.0);

    // create two triangles by assigning their vertex IDs
    object0->m_triangles->newTriangle(vertex0, vertex1, vertex2);
    object0->m_triangles->newTriangle(vertex0, vertex2, vertex3);
	
@endcode



\section section9-2 Rendering Options

In the following section we review the different rendering options 
offered in CHAI3D:


\subsection subsection9-2-1 Materials

Material properties define how a surface reflects light. They do this by 
defining color values much the same way that lights do. A material has a color 
values for diffuse (direct) light, ambient (scattered) light, and specular 
(reflected) light, but these values define how the components of light are 
reflected off the material surface. More information can be found in the 
section about materials. 

The material property can be enabled or disabled, and requires the use of
at least one light source in the world for the object to be visible.


@code

    using namespace chai3d;
	
    // create a mesh
    cMesh* mesh = new cMesh();

    // add mesh to world
    world->addChild(mesh);

    // build mesh using a cylinder primitive
    cCreatePipe(mesh, 
                0.15,
                0.05,
                0.06,
                32,
                1,
                cVector3d(-0.05,-0.20, 0.0), 
                cMatrix3d(cDegToRad(0), cDegToRad(0), cDegToRad(170), C_EULER_ORDER_XYZ)
                );

	// enable material property
	cylinder->setUseMaterial(true);
	
    // (1) set material by simply assigning a color name
    mesh->m_material->setBlueCornflower();
	
	// (2) or set material by assigning a color values for each component
    mesh->m_material->m_ambient.set(0.2, 0.1, 0.1);
    mesh->m_material->m_diffuse.set(0.6, 0.3, 0.3);
    mesh->m_material->m_specular.set(1.0, 1.0, 1.0);
    mesh->m_material->setShininess(10);	

@endcode


\subsection subsection9-2-2 Vertex Colors

Different color values can be specified for each vertex of the mesh.
If three vertices of a triangle share different colors, then the color 
at any point on the triangle is computed through interpolation of the
three vertex colors.

\image html images/fig-mesh-colors.png "Triangles and vertex colors."

If the material property is enabled, vertex colors are combined with the 
material color. It is common to set the material to white and assign 
colors to the different vertices to produce a desired light shading. 
If the material property is disabled, then all light sources are ignored 
and the pure vertex color is used to render the object. 


@code

    using namespace chai3d;
	
    // create a mesh
    cMesh* mesh = new cMesh();

    // add mesh to world
    world->addChild(mesh);
	
	// create three new vertices
	int vertex0 = mesh->newVertex();
	int vertex1 = mesh->newVertex();
	int vertex2 = mesh->newVertex();

	// set position of each vertex
	mesh->m_vertices->setLocalPos(vertex0, 0.0, 0.0, 0.0);
	mesh->m_vertices->setLocalPos(vertex1, 0.0, 1.0, 0.0);
	mesh->m_vertices->setLocalPos(vertex2, 1.0, 1.0, 0.0);

	// assign color value to each vertex
	cColorf color(1.0, 0.2, 0.2);
	mesh->m_vertices->setColor(vertex0, color);
	mesh->m_vertices->setColor(vertex1, color);
	mesh->m_vertices->setColor(vertex2, color);

	// create new triangle from vertices
	mesh->newTriangle(vertex0, vertex1, vertex2);
	
	// enable vertex colors
	mesh->setUseVertexColors(true);
	
    // compute surface normals
    mesh->computeAllNormals();

@endcode



\subsection subsection9-2-3 Texture Mapping

\image html images/fig-texture.png "Texture mapping."

A texture map is applied (mapped) to the surface of a shape or polygon. This process 
is akin to applying patterned paper to a plain white box. Every vertex in a polygon 
is assigned a texture coordinate (which in the 2d case is also known as a UV coordinate) 
either via explicit assignment or by procedural definition. Image sampling locations 
are then interpolated across the face of a polygon to produce a visual result that 
seems to have more richness than could otherwise be achieved with a limited number 
of polygons.

To understand how to create a texture in CHAI3D, see the first example at the top 
of this page.


\subsection subsection9-2-4 Wireframe

Triangles can be rendered in either solid or wire mode.

\image html images/fig-mesh-wireframe.png "(LEFT) Solid Mode. (RIGHT) Wireframe Mode."


@code

    using namespace chai3d;
	
	// enable wireframe rendering mode
	mesh->setWireMode(true);
	
	// enable solid rendering mode
	mesh->setWireMode(false);
	
@endcode 


\subsection subsection9-2-5 Edges

To render edges and triangles simultaneously, CHAI3D offers the option to display the 
triangles and overlay a subset of edges that are selected according to a desired
minimum angle between adjacent triangles. 

\image html images/fig-mesh-edges.png "(LEFT) Solid and Edges. (RIGHT) Edges only."


@code

    using namespace chai3d;
	
    // compute all edges for which adjacent triangles have more than 40 degrees angle
    mesh->computeAllEdges(40);

    // set line width of edges and color
    cColorf color;
    color.setBlack();
    mesh->setEdgeProperties(1, color);	
	
	// (1) enable surfaces and edges
	mesh->setShowTriangles(true);
	mesh->setShowEdges(true);
	
	// (2) enable edges only
	mesh->setShowTriangles(false);
	mesh->setShowEdges(true);
	
@endcode 


\subsection subsection9-2-6 Face Culling

Back-face culling determines whether a triangle of a mesh object 
is visible. It is a step in the graphical pipeline that tests whether 
the vertices in the triangle appear in clockwise order when projected 
onto the screen. 


@code

	using namespace chai3d;
		
    // enable culling
    object->setUseCulling(true);

@endcode


If face culling is enabled, but the polygon projected on the 
screen has a counter-clockwise winding then it has been rotated to 
face away from the camera and will not be drawn.

The process makes rendering objects quicker and more efficient by 
reducing the number of polygons for the program to draw. For example, 
in a city street scene, there is generally no need to draw the polygons 
on the sides of the buildings facing away from the camera; they are 
completely occluded by the sides facing the camera.

In general, back-face culling can be assumed to produce no visible artifact 
in a rendered scene if it contains only closed and opaque geometry. 
In scenes containing transparent polygons, rear facing polygons may become 
visible through the process of alpha composition.


\subsection subsection9-2-7 Transparency, Translucency, and Blending

\image html images/fig-mesh-transparency.png "Rendering the translucent lens of a camera."

A transparent physical material shows objects behind it as unobscured and 
doesn't reflect light off its surface. Clear glass is a nearly transparent 
material. Although glass allows most light to pass through unobscured, in 
reality it also reflects some light. A perfectly transparent material is 
completely invisible.

A translucent physical material shows objects behind it, but those objects 
are obscured by the translucent material. In addition, a translucent material 
reflects some of the light that hits it, making the material visible. Physical 
examples of translucent materials include sheer cloth, thin plastic, and smoked 
glass.

Transparent and translucent are often used synonymously. Materials that are 
neither transparent nor translucent are opaque.

Blending is OpenGL's mechanism for combining color already in the framebuffer 
with the color of the incoming primitive. The result of this combination is then 
stored back in the framebuffer. Blending is frequently used to simulate translucent 
physical materials. One example is rendering the smoked glass windshield of a car. 
The driver and interior are still visible, but they are obscured by the dark color 
of the smoked glass.


@code

    using namespace chai3d;
	
    // enable multi-pass rendering to handle transparent objects
    camera->setUseMultipassTransparency(true);

    // enable transparency to current mesh
    mesh->setUseCulling(true);
	
	// assign a general transparency to the object
	mesh->setTransparencyLevel(0.7);
	
@endcode


\subsection subsection9-2-8 Surface Normals

\image html images/fig-mesh-normals.png "Rendering the vertex normals of a mesh."

When lighting is enabled in CHAI3D, the normal vectors are used to determine how much 
light is received at the specified vertex or surface. If the surface normals have not 
been defined, they can be computed for every triangle by taking the vector cross product 
of two edges of that triangle.

For debugging purposes, surface normals can be displayed using the following calls:


@code

    using namespace chai3d;
	
	// compute all surface normals
    mesh->computeAllNormals();

    // set normal properties for display
    cColorf color;
    color.setOrangeTomato();
    mesh->setNormalsProperties(0.01, color);
	
	// display surface normals
	mesh->setShowNormals(true);

@endcode



\section section9-3 Multi Mesh Objects

\subsection subsection9-3-1 Introduction

Since mesh objects only contains a single material and texture property each, 
creating meshes that use a collection of materials and textures requires 
using a different class called \ref chai3d::cMultiMesh "cMultiMesh" which concatenates a list
of meshes together. By organizing triangles according to their material
and texture property in separate mesh objects, it is possible to efficiently 
build and render complex objects with a rich set of properties.


@code

    using namespace chai3d;
	
    // create a multi mesh object
    cMultiMesh* multiMesh = new cMultiMesh();

    // add multi mesh object to world
    world->addChild(multiMesh);

    // create a first mesh
    cMesh* mesh1 = multiMesh->newMesh();

    // create a second mesh
    cMesh* mesh2 = multiMesh->newMesh();
	
@endcode


\subsection subsection9-3-2 File Support

CHAI3D supports 3DS, OBJ, and SLT file formats to import or export models.
If you wish you import files of a different format, you can use applications
such as <a href="http://www.blender.org" target="_blank">Blender</a> or 
<a href="http://www.sap.com/solution/lob/r-and-d/software/product-visualization/index.html" target="_blank">
Visual Enterprise Author</a> (formerly known as Deep Exploration) to edit and convert files to desired formats.


@code
    
	using namespace chai3d;
	
    // load 3DS model file
    multiMesh->loadFromFile("myModel.3ds");

    // load OBJ model file
    multiMesh->loadFromFile("myModel.obj");

   // load STL model file
    multiMesh->loadFromFile("myModel.stl");
	
    // save model to 3DS file
    multiMesh->saveToFile("myModel.3ds");

    // save model to OBJ file
    multiMesh->saveToFile("myModel.obj");

    // save model to STL file
    multiMesh->saveToFile("myModel.stl");
	
@endcode


\section section9-4 Collision Detection

A collision detector is used to compute the intersection between a ray and any of
the triangles that compose a mesh (or multi-mesh). In order for this operation to 
proceed quickly, CHAI3D uses a bounding volume hierarchy or BVH. A BVH is a tree 
structure on a set of geometric objects. All geometric objects are wrapped in 
bounding volumes that form the leaf nodes of the tree. These nodes are then 
grouped as small sets and enclosed within larger bounding volumes. 
These, in turn, are also grouped and enclosed within other larger bounding volumes 
in a recursive fashion, eventually resulting in a tree structure with a single 
bounding volume at the top of the tree. Bounding volume hierarchies are used 
to support several operations on sets of geometric objects efficiently, such as 
in collision detection for haptic interaction computation, ray tracing, or mouse 
selection.

\image html images/fig-collision.png "Axis aligned bounding volume hierarchy."

In CHAI3D, bounding volume hierarchies must be generated <span style="text-decoration: underline;">after</span>
the triangles have been defined. If the triangles are modified, or vertices moved, then the 
hierarchy must be computed again. When updating the collision tree, it is 
important to correctly include the radius of the largest haptic point used in 
the world. This information is used to create an envelope large enough to detect 
any interaction with contact points that have a radius smaller or equal to the 
defined threshold.


@code

    using namespace chai3d;
	
    // create axis aligned bounding volume hierarchy
    multiMesh->createAABBCollisionDetector(toolRadius);
	
@endcode


\section section9-5 Haptic Effects

\image html images/fig-mesh-proxy.png "Haptic rendering of mesh objects."

To haptically render mesh objects, CHAI3D uses a virtual "finger-proxy" algorithm developed 
by Ruspini and Khatib, similar to the "god-object" proposed by Zilles and Salisbury. 
The virtual proxy is a representative object that substitutes for the physical finger 
or probe in the virtual environment. 

\image html images/fig-mesh-ruspini.png "Finger-proxy algorithm by Ruspini and Khatib."


The above figure illustrates the motion of the virtual proxy, 
as the haptic devices's position is altered. The motion of the proxy attemps to always 
move toward a goal. When unobstructed, the proxy moves directly towards the goal. When
the proxy encounters an obstacle, direct motion is not possible, but the proxy may 
still be able to reduce the distance to the goal by moving along one or more of the 
constraint surfaces. The motion is chosen to locally minimize the distance to the
goal. When the proxy is unable to decrease its distance to the goal, it stops at the 
local minimum configuration. Forces are computed by modelling a virtual spring between 
the position of the haptic device and the proxy. The stiffness of the spring is 
defined in the material property.


@code

    using namespace chai3d;
	
    // create collision detector
    mesh->createAABBCollisionDetector(toolRadius);

    // set haptic properties
    mesh->m_material->setStiffness(1000);
    mesh->m_material->setStaticFriction(0.3);
    mesh->m_material->setDynamicFriction(0.4);
	
@endcode


Additional haptic effects can also be activated and adjusted through the material 
property class. Haptic effects use potential field algorithms which
are also supported on any generic shape object. Please note that the magnetic effect
is not currently supported on mesh objects. 


@code

    using namespace chai3d;
	
    // create a haptic stick-slip effect
    mesh->createEffectStickSlip();

    // set haptic properties
    mesh->m_material->setStickSlipForceMax(5.0);
    mesh->m_material->setStickSlipStiffness(1000);
	
@endcode

*/
